Summary

The Rust code provides a solid, modern architectural foundation. The memory-unsafe, C-style data structures are gone. However, to produce a bit-for-bit identical (and therefore valid) IW44 file, several critical logic sections need to be implemented or refined.

The work can be broken down into three categories:

    Critical Gaps for Correctness: These must be fixed to produce a valid, compatible file.

    Important Missing Features: The encoder will be incomplete without these.

    Refinements & Performance: Required to match the original's capabilities and speed.

1. Critical Gaps for Correctness / Bit-Compatibility

These are the highest priority. The current Rust code will produce incorrect output because of these gaps.
1.1. ZPCodec Arithmetic Coder

    C++: Uses a real, complex ZPCodec for arithmetic/range coding. This is the heart of the entropy coding.

    Rust: Currently uses zp_codec_mock::ZPCodec, which does nothing.

    Gap: This is the single largest missing piece. Without a real ZPCodec, the encode_slice function doesn't actually produce any compressed bits. The entire output is empty.

    Action: You must implement or integrate a real arithmetic coder that matches the behavior of DjVu's ZP-coder, including the specific IWencoder logic.

1.2. Bucket & Coefficient Context Calculation

    C++: In IW44Image::Codec::Encode::encode_buckets, the contexts for ctxStart and ctxBucket are calculated based on neighboring coefficients and active states (#ifndef NOCTX_...). These contexts are crucial as they select which probability model the ZPCodec uses for the next bit.

    Rust: The encode_buckets function in codec.rs has explicit // TODO markers where this logic should be. It currently uses a simplified, hardcoded context index (e.g., ctx_idx = 0).

    Gap: Using the wrong context will cause the arithmetic coder to produce a completely different, incorrect bitstream. This is a bit-compatibility blocker.

    Action: The context calculation logic from C++ must be ported precisely. This involves looking at parent-band coefficients (eblk) and tracking the number of unknown coefficients (gotcha).

1.3. Wavelet Filter Boundary Handling (filter_fh)

    C++: The horizontal filter filter_fh has very specific, stateful logic for handling the first and last few coefficients in a row to avoid reading out of bounds. It carries state in variables a0..a3 and b0..b3.

    Rust: The Rust port transform::filter_fh uses a temporary deltas vector, which is a good refactoring. However, its boundary logic is marked as "Simplified boundary handling". It does not precisely replicate the complex edge cases from the C++ while loops (e.g., the x=1 special case, or the final updates for w <= x < w+3).

    Gap: Incorrect boundary handling will result in different wavelet coefficients at the edges of every row, making the entire file non-compatible.

    Action: Carefully port the exact boundary logic from the C++ filter_fh's while loops into the Rust implementation. This is tedious but essential. The filter_fv also has similar, though less complex, boundary issues that need verification.

1.4. Fixed-Point Color Conversion

    C++: RGB_to_Y, RGB_to_Cb, and RGB_to_Cr use pre-calculated integer tables and bit-shifting (rmul, gmul, bmul, >> 16) to perform fixed-point arithmetic. This is deterministic and fast.

    Rust: The current transform::rgb_to_y (and Cb/Cr) functions use f32 floating-point arithmetic.

    Gap: Floating-point math is not guaranteed to be identical across platforms and is certainly not bit-for-bit identical to the C++ fixed-point implementation. This will lead to slightly different Y, Cb, and Cr input values, resulting in a different compressed output.

    Action: Rewrite the Rust color conversion functions to use fixed-point integer arithmetic, replicating the C++ logic of pre-multiplying by 0x10000 and right-shifting.

2. Important Missing Features
2.1. Mask Processing

    C++: IW44Image::Map::Encode::create has a code path that calls interpolate_mask and forward_mask if a mask is provided. This is a complex, multi-resolution algorithm to fill in masked areas with low-cost data.

    Rust: coeff_map::CoeffMap::create_from_image has an explicit // TODO and a log::warn! for this. It completely skips this logic.

    Gap: The encoder cannot correctly process masked images, which is a key feature of DjVu for separating foreground/background.

    Action: Port the interpolate_mask and forward_mask algorithms. This is a significant piece of work.

2.2. IFF Chunk Header Writing

    C++: The encode_iff and encode_chunk methods in IWBitmap::Encode and IWPixmap::Encode write the FORM:BM44, BM44, PrimaryHeader, SecondaryHeader, and TertiaryHeader chunks.

    Rust: The public API in encoder.rs returns only the raw compressed data (Vec<u8>). It does not create the necessary IFF structure around it.

    Gap: The user of the Rust library would need to manually construct the IFF file structure, which the original library did automatically.

    Action: Add functions to the IWEncoder to write the complete IFF headers for each chunk, using the parameters (width, height, crcb_delay, etc.) stored in the encoder state.

3. Refinements and Performance
3.1. SIMD Implementation

    C++: Contains MMX versions of the vertical filters (mmx_fv_1, mmx_fv_2).

    Rust: This was correctly identified as obsolete and stripped. The current implementation is scalar-only.

    Gap: The Rust version will be slower than the C++ version on compatible hardware.

    Action: This is a lower priority. After correctness is established, you can add modern SIMD versions of the filter hot loops (e.g., filter_fv_row) using std::arch for AVX2/SSE2, guarded by #[cfg(target_feature = "...")] and runtime detection.

At-a-Glance Status Table
Feature	C++ Implementation	Rust Port Status	Priority
Core Logic			
ZPCodec	Complete arithmetic coder	Missing (Mocked)	Critical
Codec Contexts	Detailed, stateful logic	Missing (Placeholder)	Critical
Wavelet filter_fh	Precise boundary logic	Incomplete/Simplified	Critical
Color Conversion	Fixed-point integer math	Floating-point (incorrect)	Critical
Features			
Mask Processing	interpolate_mask, forward_mask	Missing (TODO)	High
IFF Header Writing	Full FORM/chunk/header logic	Missing	Medium
estimate_decibel	Complete	Ported Correctly	Done
Data Structures			
Coeff Storage	Manual C-style pools	Safe HashMap	Done
Performance			
SIMD Filters	MMX (obsolete)	Scalar Only	Low

While this list might seem long, the hardest part—refactoring the overall architecture into safe, modern Rust—is complete. The remaining work is now a more direct, albeit highly detailed, porting of specific algorithms. Your next focus should be entirely on the "Critical" items to achieve a correct, bit-compatible output.
Thinking Thoughts (experimental)
Auto

Expand to view model thoughts
chevron_right
